// Code generated by go awsdoublegen; DO NOT EDIT.
// This file was generated at 2020-01-29T21:22:05+11:00
package databasemigrationservicedouble

import (
	"time"

	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/lwoggardner/awsdouble"
)

var waiters = map[string]*awsdouble.Waiter{

	"EndpointDeleted": &awsdouble.Waiter{
		OperationName: "DescribeEndpoints",
		Waiter: request.Waiter{
			Name:        "WaitUntilEndpointDeleted",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(5 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "ResourceNotFoundFault",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Endpoints[].Status",
					Expected: "active",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Endpoints[].Status",
					Expected: "creating",
				},
			},
		},
	},

	"ReplicationInstanceAvailable": &awsdouble.Waiter{
		OperationName: "DescribeReplicationInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationInstanceAvailable",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(60 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "deleting",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "incompatible-credentials",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "incompatible-network",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "inaccessible-encryption-credentials",
				},
			},
		},
	},

	"ReplicationInstanceDeleted": &awsdouble.Waiter{
		OperationName: "DescribeReplicationInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationInstanceDeleted",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationInstances[].ReplicationInstanceStatus",
					Expected: "available",
				},
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "ResourceNotFoundFault",
				},
			},
		},
	},

	"ReplicationTaskDeleted": &awsdouble.Waiter{
		OperationName: "DescribeReplicationTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationTaskDeleted",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "ready",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "creating",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopped",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "failed",
				},
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "ResourceNotFoundFault",
				},
			},
		},
	},

	"ReplicationTaskReady": &awsdouble.Waiter{
		OperationName: "DescribeReplicationTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationTaskReady",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "ready",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "starting",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopping",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopped",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "failed",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "modifying",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "testing",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "deleting",
				},
			},
		},
	},

	"ReplicationTaskRunning": &awsdouble.Waiter{
		OperationName: "DescribeReplicationTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationTaskRunning",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "ready",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "creating",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopping",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopped",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "failed",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "modifying",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "testing",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "deleting",
				},
			},
		},
	},

	"ReplicationTaskStopped": &awsdouble.Waiter{
		OperationName: "DescribeReplicationTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilReplicationTaskStopped",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "stopped",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "ready",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "creating",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "starting",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "failed",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "modifying",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "testing",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ReplicationTasks[].Status",
					Expected: "deleting",
				},
			},
		},
	},

	"TestConnectionSucceeds": &awsdouble.Waiter{
		OperationName: "DescribeConnections",
		Waiter: request.Waiter{
			Name:        "WaitUntilTestConnectionSucceeds",
			MaxAttempts: 60,
			Delay:       request.ConstantWaiterDelay(5 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Connections[].Status",
					Expected: "successful",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Connections[].Status",
					Expected: "failed",
				},
			},
		},
	},
}
