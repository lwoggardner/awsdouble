// Code generated by go doublegen; DO NOT EDIT.
// This file was generated at 2020-02-14T22:13:39+11:00

// Package lexruntimeservicedouble provides a TestDouble implementation of lexruntimeserviceiface.LexRuntimeServiceAPI
package lexruntimeservicedouble

import (
	"context"

	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/lexruntimeservice"
	"github.com/aws/aws-sdk-go/service/lexruntimeservice/lexruntimeserviceiface"
	"github.com/lwoggardner/awsdouble"
	"github.com/lwoggardner/godouble/godouble"
)

// LexRuntimeServiceDouble is TestDouble for lexruntimeserviceiface.LexRuntimeServiceAPI
type LexRuntimeServiceDouble struct {
	lexruntimeserviceiface.LexRuntimeServiceAPI
	*awsdouble.AWSTestDouble
}

// Constructor for LexRuntimeServiceDouble
// Default configuration will ensure
//   * API operations not explicitly stubbed will return an empty output struct pointer, and nil error.
//     To simulate long polling, "Poll" operations will return these values after a random delay of up to 100ms.
//   * WithContext methods implement a 'Fake' method that returns a cancellation error if the context is cancelled
//      before the method is called.
//   * Pages and PagesWithContext methods similarly implement a 'Fake' method that paginates over the underlying method.
//
//    This allows tests to only stub the simple api methods and be generally unconcerned whether the SUT is using the
//      Context or Pagination forms of the API.
//
func NewDouble(t godouble.T, configurators ...func(*awsdouble.AWSTestDouble)) *LexRuntimeServiceDouble {
	result := &LexRuntimeServiceDouble{}

	configurators = append([]func(configurator *awsdouble.AWSTestDouble){func(d *awsdouble.AWSTestDouble) {
		d.SetDefaultCall(result.defaultMethodCall)
		d.SetDefaultReturnValues(result.defaultReturnValues)
	}}, configurators...)

	result.AWSTestDouble = awsdouble.NewDouble(t, (*lexruntimeserviceiface.LexRuntimeServiceAPI)(nil), configurators...)
	return result
}

func (d *LexRuntimeServiceDouble) defaultReturnValues(m godouble.Method) godouble.ReturnValues {
	return d.DefaultReturnValues(m)
}

func (d *LexRuntimeServiceDouble) defaultMethodCall(m godouble.Method) godouble.MethodCall {
	switch m.Reflect().Name {

	case "DeleteSessionWithContext":
		return m.Fake(d.fakeDeleteSessionWithContext)

	case "GetSessionWithContext":
		return m.Fake(d.fakeGetSessionWithContext)

	case "PostContentWithContext":
		return m.Fake(d.fakePostContentWithContext)

	case "PostTextWithContext":
		return m.Fake(d.fakePostTextWithContext)

	case "PutSessionWithContext":
		return m.Fake(d.fakePutSessionWithContext)

	default:
		return nil
	}
}

func (d *LexRuntimeServiceDouble) DeleteSession(i0 *lexruntimeservice.DeleteSessionInput) (r0 *lexruntimeservice.DeleteSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteSession", i0)
	r0, _ = returns[0].(*lexruntimeservice.DeleteSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) DeleteSessionRequest(i0 *lexruntimeservice.DeleteSessionInput) (r0 *request.Request, r1 *lexruntimeservice.DeleteSessionOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteSessionRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*lexruntimeservice.DeleteSessionOutput)
	return
}

func (d *LexRuntimeServiceDouble) DeleteSessionWithContext(i0 context.Context, i1 *lexruntimeservice.DeleteSessionInput, i2 ...request.Option) (r0 *lexruntimeservice.DeleteSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteSessionWithContext", i0, i1, i2)
	r0, _ = returns[0].(*lexruntimeservice.DeleteSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) fakeDeleteSessionWithContext(ctx context.Context, in *lexruntimeservice.DeleteSessionInput, _ ...request.Option) (*lexruntimeservice.DeleteSessionOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "DeleteSession cancelled", ctx.Err())
	default:
		return d.DeleteSession(in)
	}
}

func (d *LexRuntimeServiceDouble) GetSession(i0 *lexruntimeservice.GetSessionInput) (r0 *lexruntimeservice.GetSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetSession", i0)
	r0, _ = returns[0].(*lexruntimeservice.GetSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) GetSessionRequest(i0 *lexruntimeservice.GetSessionInput) (r0 *request.Request, r1 *lexruntimeservice.GetSessionOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetSessionRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*lexruntimeservice.GetSessionOutput)
	return
}

func (d *LexRuntimeServiceDouble) GetSessionWithContext(i0 context.Context, i1 *lexruntimeservice.GetSessionInput, i2 ...request.Option) (r0 *lexruntimeservice.GetSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetSessionWithContext", i0, i1, i2)
	r0, _ = returns[0].(*lexruntimeservice.GetSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) fakeGetSessionWithContext(ctx context.Context, in *lexruntimeservice.GetSessionInput, _ ...request.Option) (*lexruntimeservice.GetSessionOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "GetSession cancelled", ctx.Err())
	default:
		return d.GetSession(in)
	}
}

func (d *LexRuntimeServiceDouble) PostContent(i0 *lexruntimeservice.PostContentInput) (r0 *lexruntimeservice.PostContentOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostContent", i0)
	r0, _ = returns[0].(*lexruntimeservice.PostContentOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) PostContentRequest(i0 *lexruntimeservice.PostContentInput) (r0 *request.Request, r1 *lexruntimeservice.PostContentOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostContentRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*lexruntimeservice.PostContentOutput)
	return
}

func (d *LexRuntimeServiceDouble) PostContentWithContext(i0 context.Context, i1 *lexruntimeservice.PostContentInput, i2 ...request.Option) (r0 *lexruntimeservice.PostContentOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostContentWithContext", i0, i1, i2)
	r0, _ = returns[0].(*lexruntimeservice.PostContentOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) fakePostContentWithContext(ctx context.Context, in *lexruntimeservice.PostContentInput, _ ...request.Option) (*lexruntimeservice.PostContentOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "PostContent cancelled", ctx.Err())
	default:
		return d.PostContent(in)
	}
}

func (d *LexRuntimeServiceDouble) PostText(i0 *lexruntimeservice.PostTextInput) (r0 *lexruntimeservice.PostTextOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostText", i0)
	r0, _ = returns[0].(*lexruntimeservice.PostTextOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) PostTextRequest(i0 *lexruntimeservice.PostTextInput) (r0 *request.Request, r1 *lexruntimeservice.PostTextOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostTextRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*lexruntimeservice.PostTextOutput)
	return
}

func (d *LexRuntimeServiceDouble) PostTextWithContext(i0 context.Context, i1 *lexruntimeservice.PostTextInput, i2 ...request.Option) (r0 *lexruntimeservice.PostTextOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PostTextWithContext", i0, i1, i2)
	r0, _ = returns[0].(*lexruntimeservice.PostTextOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) fakePostTextWithContext(ctx context.Context, in *lexruntimeservice.PostTextInput, _ ...request.Option) (*lexruntimeservice.PostTextOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "PostText cancelled", ctx.Err())
	default:
		return d.PostText(in)
	}
}

func (d *LexRuntimeServiceDouble) PutSession(i0 *lexruntimeservice.PutSessionInput) (r0 *lexruntimeservice.PutSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PutSession", i0)
	r0, _ = returns[0].(*lexruntimeservice.PutSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) PutSessionRequest(i0 *lexruntimeservice.PutSessionInput) (r0 *request.Request, r1 *lexruntimeservice.PutSessionOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PutSessionRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*lexruntimeservice.PutSessionOutput)
	return
}

func (d *LexRuntimeServiceDouble) PutSessionWithContext(i0 context.Context, i1 *lexruntimeservice.PutSessionInput, i2 ...request.Option) (r0 *lexruntimeservice.PutSessionOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("PutSessionWithContext", i0, i1, i2)
	r0, _ = returns[0].(*lexruntimeservice.PutSessionOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *LexRuntimeServiceDouble) fakePutSessionWithContext(ctx context.Context, in *lexruntimeservice.PutSessionInput, _ ...request.Option) (*lexruntimeservice.PutSessionOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "PutSession cancelled", ctx.Err())
	default:
		return d.PutSession(in)
	}
}
