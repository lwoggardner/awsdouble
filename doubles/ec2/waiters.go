// Code generated by go awsdoublegen; DO NOT EDIT.
// This file was generated at 2020-01-29T21:22:05+11:00
package ec2double

import (
	"time"

	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/lwoggardner/awsdouble"
)

var waiters = map[string]*awsdouble.Waiter{

	"BundleTaskComplete": &awsdouble.Waiter{
		OperationName: "DescribeBundleTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilBundleTaskComplete",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "BundleTasks[].State",
					Expected: "complete",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "BundleTasks[].State",
					Expected: "failed",
				},
			},
		},
	},

	"ConversionTaskCancelled": &awsdouble.Waiter{
		OperationName: "DescribeConversionTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilConversionTaskCancelled",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ConversionTasks[].State",
					Expected: "cancelled",
				},
			},
		},
	},

	"ConversionTaskCompleted": &awsdouble.Waiter{
		OperationName: "DescribeConversionTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilConversionTaskCompleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ConversionTasks[].State",
					Expected: "completed",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ConversionTasks[].State",
					Expected: "cancelled",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "ConversionTasks[].State",
					Expected: "cancelling",
				},
			},
		},
	},

	"ConversionTaskDeleted": &awsdouble.Waiter{
		OperationName: "DescribeConversionTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilConversionTaskDeleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ConversionTasks[].State",
					Expected: "deleted",
				},
			},
		},
	},

	"CustomerGatewayAvailable": &awsdouble.Waiter{
		OperationName: "DescribeCustomerGateways",
		Waiter: request.Waiter{
			Name:        "WaitUntilCustomerGatewayAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "CustomerGateways[].State",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "CustomerGateways[].State",
					Expected: "deleted",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "CustomerGateways[].State",
					Expected: "deleting",
				},
			},
		},
	},

	"ExportTaskCancelled": &awsdouble.Waiter{
		OperationName: "DescribeExportTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilExportTaskCancelled",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ExportTasks[].State",
					Expected: "cancelled",
				},
			},
		},
	},

	"ExportTaskCompleted": &awsdouble.Waiter{
		OperationName: "DescribeExportTasks",
		Waiter: request.Waiter{
			Name:        "WaitUntilExportTaskCompleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "ExportTasks[].State",
					Expected: "completed",
				},
			},
		},
	},

	"ImageAvailable": &awsdouble.Waiter{
		OperationName: "DescribeImages",
		Waiter: request.Waiter{
			Name:        "WaitUntilImageAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Images[].State",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Images[].State",
					Expected: "failed",
				},
			},
		},
	},

	"ImageExists": &awsdouble.Waiter{
		OperationName: "DescribeImages",
		Waiter: request.Waiter{
			Name:        "WaitUntilImageExists",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathWaiterMatch, Argument: "length(Images[]) > `0`",
					Expected: true,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidAMIID.NotFound",
				},
			},
		},
	},

	"InstanceExists": &awsdouble.Waiter{
		OperationName: "DescribeInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilInstanceExists",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(5 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathWaiterMatch, Argument: "length(Reservations[]) > `0`",
					Expected: true,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidInstanceID.NotFound",
				},
			},
		},
	},

	"InstanceRunning": &awsdouble.Waiter{
		OperationName: "DescribeInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilInstanceRunning",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "shutting-down",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "terminated",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "stopping",
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidInstanceID.NotFound",
				},
			},
		},
	},

	"InstanceStatusOk": &awsdouble.Waiter{
		OperationName: "DescribeInstanceStatus",
		Waiter: request.Waiter{
			Name:        "WaitUntilInstanceStatusOk",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "InstanceStatuses[].InstanceStatus.Status",
					Expected: "ok",
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidInstanceID.NotFound",
				},
			},
		},
	},

	"InstanceStopped": &awsdouble.Waiter{
		OperationName: "DescribeInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilInstanceStopped",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "stopped",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "pending",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "terminated",
				},
			},
		},
	},

	"InstanceTerminated": &awsdouble.Waiter{
		OperationName: "DescribeInstances",
		Waiter: request.Waiter{
			Name:        "WaitUntilInstanceTerminated",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "terminated",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "pending",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Reservations[].Instances[].State.Name",
					Expected: "stopping",
				},
			},
		},
	},

	"KeyPairExists": &awsdouble.Waiter{
		OperationName: "DescribeKeyPairs",
		Waiter: request.Waiter{
			Name:        "WaitUntilKeyPairExists",
			MaxAttempts: 6,
			Delay:       request.ConstantWaiterDelay(5 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathWaiterMatch, Argument: "length(KeyPairs[].KeyName) > `0`",
					Expected: true,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidKeyPair.NotFound",
				},
			},
		},
	},

	"NatGatewayAvailable": &awsdouble.Waiter{
		OperationName: "DescribeNatGateways",
		Waiter: request.Waiter{
			Name:        "WaitUntilNatGatewayAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "NatGateways[].State",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "NatGateways[].State",
					Expected: "failed",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "NatGateways[].State",
					Expected: "deleting",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "NatGateways[].State",
					Expected: "deleted",
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "NatGatewayNotFound",
				},
			},
		},
	},

	"NetworkInterfaceAvailable": &awsdouble.Waiter{
		OperationName: "DescribeNetworkInterfaces",
		Waiter: request.Waiter{
			Name:        "WaitUntilNetworkInterfaceAvailable",
			MaxAttempts: 10,
			Delay:       request.ConstantWaiterDelay(20 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "NetworkInterfaces[].Status",
					Expected: "available",
				},
				{
					State:    request.FailureWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidNetworkInterfaceID.NotFound",
				},
			},
		},
	},

	"PasswordDataAvailable": &awsdouble.Waiter{
		OperationName: "GetPasswordData",
		Waiter: request.Waiter{
			Name:        "WaitUntilPasswordDataAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathWaiterMatch, Argument: "length(PasswordData) > `0`",
					Expected: true,
				},
			},
		},
	},

	"SecurityGroupExists": &awsdouble.Waiter{
		OperationName: "DescribeSecurityGroups",
		Waiter: request.Waiter{
			Name:        "WaitUntilSecurityGroupExists",
			MaxAttempts: 6,
			Delay:       request.ConstantWaiterDelay(5 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathWaiterMatch, Argument: "length(SecurityGroups[].GroupId) > `0`",
					Expected: true,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidGroupNotFound",
				},
			},
		},
	},

	"SnapshotCompleted": &awsdouble.Waiter{
		OperationName: "DescribeSnapshots",
		Waiter: request.Waiter{
			Name:        "WaitUntilSnapshotCompleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Snapshots[].State",
					Expected: "completed",
				},
			},
		},
	},

	"SpotInstanceRequestFulfilled": &awsdouble.Waiter{
		OperationName: "DescribeSpotInstanceRequests",
		Waiter: request.Waiter{
			Name:        "WaitUntilSpotInstanceRequestFulfilled",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "fulfilled",
				},
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "request-canceled-and-instance-running",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "schedule-expired",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "canceled-before-fulfillment",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "bad-parameters",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "SpotInstanceRequests[].Status.Code",
					Expected: "system-error",
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidSpotInstanceRequestID.NotFound",
				},
			},
		},
	},

	"SubnetAvailable": &awsdouble.Waiter{
		OperationName: "DescribeSubnets",
		Waiter: request.Waiter{
			Name:        "WaitUntilSubnetAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Subnets[].State",
					Expected: "available",
				},
			},
		},
	},

	"SystemStatusOk": &awsdouble.Waiter{
		OperationName: "DescribeInstanceStatus",
		Waiter: request.Waiter{
			Name:        "WaitUntilSystemStatusOk",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "InstanceStatuses[].SystemStatus.Status",
					Expected: "ok",
				},
			},
		},
	},

	"VolumeAvailable": &awsdouble.Waiter{
		OperationName: "DescribeVolumes",
		Waiter: request.Waiter{
			Name:        "WaitUntilVolumeAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Volumes[].State",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Volumes[].State",
					Expected: "deleted",
				},
			},
		},
	},

	"VolumeDeleted": &awsdouble.Waiter{
		OperationName: "DescribeVolumes",
		Waiter: request.Waiter{
			Name:        "WaitUntilVolumeDeleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Volumes[].State",
					Expected: "deleted",
				},
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidVolume.NotFound",
				},
			},
		},
	},

	"VolumeInUse": &awsdouble.Waiter{
		OperationName: "DescribeVolumes",
		Waiter: request.Waiter{
			Name:        "WaitUntilVolumeInUse",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Volumes[].State",
					Expected: "in-use",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "Volumes[].State",
					Expected: "deleted",
				},
			},
		},
	},

	"VpcAvailable": &awsdouble.Waiter{
		OperationName: "DescribeVpcs",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpcAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "Vpcs[].State",
					Expected: "available",
				},
			},
		},
	},

	"VpcExists": &awsdouble.Waiter{
		OperationName: "DescribeVpcs",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpcExists",
			MaxAttempts: 5,
			Delay:       request.ConstantWaiterDelay(1 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.StatusWaiterMatch,
					Expected: 200,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidVpcID.NotFound",
				},
			},
		},
	},

	"VpcPeeringConnectionDeleted": &awsdouble.Waiter{
		OperationName: "DescribeVpcPeeringConnections",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpcPeeringConnectionDeleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "VpcPeeringConnections[].Status.Code",
					Expected: "deleted",
				},
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidVpcPeeringConnectionID.NotFound",
				},
			},
		},
	},

	"VpcPeeringConnectionExists": &awsdouble.Waiter{
		OperationName: "DescribeVpcPeeringConnections",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpcPeeringConnectionExists",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:    request.SuccessWaiterState,
					Matcher:  request.StatusWaiterMatch,
					Expected: 200,
				},
				{
					State:    request.RetryWaiterState,
					Matcher:  request.ErrorWaiterMatch,
					Expected: "InvalidVpcPeeringConnectionID.NotFound",
				},
			},
		},
	},

	"VpnConnectionAvailable": &awsdouble.Waiter{
		OperationName: "DescribeVpnConnections",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpnConnectionAvailable",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "VpnConnections[].State",
					Expected: "available",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "VpnConnections[].State",
					Expected: "deleting",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "VpnConnections[].State",
					Expected: "deleted",
				},
			},
		},
	},

	"VpnConnectionDeleted": &awsdouble.Waiter{
		OperationName: "DescribeVpnConnections",
		Waiter: request.Waiter{
			Name:        "WaitUntilVpnConnectionDeleted",
			MaxAttempts: 40,
			Delay:       request.ConstantWaiterDelay(15 * time.Second),
			Acceptors: []request.WaiterAcceptor{
				{
					State:   request.SuccessWaiterState,
					Matcher: request.PathAllWaiterMatch, Argument: "VpnConnections[].State",
					Expected: "deleted",
				},
				{
					State:   request.FailureWaiterState,
					Matcher: request.PathAnyWaiterMatch, Argument: "VpnConnections[].State",
					Expected: "pending",
				},
			},
		},
	},
}
