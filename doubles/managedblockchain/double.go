// Code generated by go doublegen; DO NOT EDIT.
// This file was generated at 2020-02-14T22:13:45+11:00

// Package managedblockchaindouble provides a TestDouble implementation of managedblockchainiface.ManagedBlockchainAPI
package managedblockchaindouble

import (
	"context"

	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/managedblockchain"
	"github.com/aws/aws-sdk-go/service/managedblockchain/managedblockchainiface"
	"github.com/lwoggardner/awsdouble"
	"github.com/lwoggardner/godouble/godouble"
)

// ManagedBlockchainDouble is TestDouble for managedblockchainiface.ManagedBlockchainAPI
type ManagedBlockchainDouble struct {
	managedblockchainiface.ManagedBlockchainAPI
	*awsdouble.AWSTestDouble
}

// Constructor for ManagedBlockchainDouble
// Default configuration will ensure
//   * API operations not explicitly stubbed will return an empty output struct pointer, and nil error.
//     To simulate long polling, "Poll" operations will return these values after a random delay of up to 100ms.
//   * WithContext methods implement a 'Fake' method that returns a cancellation error if the context is cancelled
//      before the method is called.
//   * Pages and PagesWithContext methods similarly implement a 'Fake' method that paginates over the underlying method.
//
//    This allows tests to only stub the simple api methods and be generally unconcerned whether the SUT is using the
//      Context or Pagination forms of the API.
//
func NewDouble(t godouble.T, configurators ...func(*awsdouble.AWSTestDouble)) *ManagedBlockchainDouble {
	result := &ManagedBlockchainDouble{}

	configurators = append([]func(configurator *awsdouble.AWSTestDouble){func(d *awsdouble.AWSTestDouble) {
		d.SetDefaultCall(result.defaultMethodCall)
		d.SetDefaultReturnValues(result.defaultReturnValues)
	}}, configurators...)

	result.AWSTestDouble = awsdouble.NewDouble(t, (*managedblockchainiface.ManagedBlockchainAPI)(nil), configurators...)
	return result
}

func (d *ManagedBlockchainDouble) defaultReturnValues(m godouble.Method) godouble.ReturnValues {
	return d.DefaultReturnValues(m)
}

func (d *ManagedBlockchainDouble) defaultMethodCall(m godouble.Method) godouble.MethodCall {
	switch m.Reflect().Name {

	case "CreateMemberWithContext":
		return m.Fake(d.fakeCreateMemberWithContext)

	case "CreateNetworkWithContext":
		return m.Fake(d.fakeCreateNetworkWithContext)

	case "CreateNodeWithContext":
		return m.Fake(d.fakeCreateNodeWithContext)

	case "CreateProposalWithContext":
		return m.Fake(d.fakeCreateProposalWithContext)

	case "DeleteMemberWithContext":
		return m.Fake(d.fakeDeleteMemberWithContext)

	case "DeleteNodeWithContext":
		return m.Fake(d.fakeDeleteNodeWithContext)

	case "GetMemberWithContext":
		return m.Fake(d.fakeGetMemberWithContext)

	case "GetNetworkWithContext":
		return m.Fake(d.fakeGetNetworkWithContext)

	case "GetNodeWithContext":
		return m.Fake(d.fakeGetNodeWithContext)

	case "GetProposalWithContext":
		return m.Fake(d.fakeGetProposalWithContext)

	case "ListInvitationsPages":
		return m.Fake(d.fakeListInvitationsPages)

	case "ListInvitationsPagesWithContext":
		return m.Fake(d.fakeListInvitationsPagesWithContext)

	case "ListInvitationsWithContext":
		return m.Fake(d.fakeListInvitationsWithContext)

	case "ListMembersPages":
		return m.Fake(d.fakeListMembersPages)

	case "ListMembersPagesWithContext":
		return m.Fake(d.fakeListMembersPagesWithContext)

	case "ListMembersWithContext":
		return m.Fake(d.fakeListMembersWithContext)

	case "ListNetworksPages":
		return m.Fake(d.fakeListNetworksPages)

	case "ListNetworksPagesWithContext":
		return m.Fake(d.fakeListNetworksPagesWithContext)

	case "ListNetworksWithContext":
		return m.Fake(d.fakeListNetworksWithContext)

	case "ListNodesPages":
		return m.Fake(d.fakeListNodesPages)

	case "ListNodesPagesWithContext":
		return m.Fake(d.fakeListNodesPagesWithContext)

	case "ListNodesWithContext":
		return m.Fake(d.fakeListNodesWithContext)

	case "ListProposalVotesPages":
		return m.Fake(d.fakeListProposalVotesPages)

	case "ListProposalVotesPagesWithContext":
		return m.Fake(d.fakeListProposalVotesPagesWithContext)

	case "ListProposalVotesWithContext":
		return m.Fake(d.fakeListProposalVotesWithContext)

	case "ListProposalsPages":
		return m.Fake(d.fakeListProposalsPages)

	case "ListProposalsPagesWithContext":
		return m.Fake(d.fakeListProposalsPagesWithContext)

	case "ListProposalsWithContext":
		return m.Fake(d.fakeListProposalsWithContext)

	case "RejectInvitationWithContext":
		return m.Fake(d.fakeRejectInvitationWithContext)

	case "VoteOnProposalWithContext":
		return m.Fake(d.fakeVoteOnProposalWithContext)

	default:
		return nil
	}
}

func (d *ManagedBlockchainDouble) CreateMember(i0 *managedblockchain.CreateMemberInput) (r0 *managedblockchain.CreateMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateMember", i0)
	r0, _ = returns[0].(*managedblockchain.CreateMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) CreateMemberRequest(i0 *managedblockchain.CreateMemberInput) (r0 *request.Request, r1 *managedblockchain.CreateMemberOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateMemberRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.CreateMemberOutput)
	return
}

func (d *ManagedBlockchainDouble) CreateMemberWithContext(i0 context.Context, i1 *managedblockchain.CreateMemberInput, i2 ...request.Option) (r0 *managedblockchain.CreateMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateMemberWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.CreateMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeCreateMemberWithContext(ctx context.Context, in *managedblockchain.CreateMemberInput, _ ...request.Option) (*managedblockchain.CreateMemberOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "CreateMember cancelled", ctx.Err())
	default:
		return d.CreateMember(in)
	}
}

func (d *ManagedBlockchainDouble) CreateNetwork(i0 *managedblockchain.CreateNetworkInput) (r0 *managedblockchain.CreateNetworkOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNetwork", i0)
	r0, _ = returns[0].(*managedblockchain.CreateNetworkOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) CreateNetworkRequest(i0 *managedblockchain.CreateNetworkInput) (r0 *request.Request, r1 *managedblockchain.CreateNetworkOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNetworkRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.CreateNetworkOutput)
	return
}

func (d *ManagedBlockchainDouble) CreateNetworkWithContext(i0 context.Context, i1 *managedblockchain.CreateNetworkInput, i2 ...request.Option) (r0 *managedblockchain.CreateNetworkOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNetworkWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.CreateNetworkOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeCreateNetworkWithContext(ctx context.Context, in *managedblockchain.CreateNetworkInput, _ ...request.Option) (*managedblockchain.CreateNetworkOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "CreateNetwork cancelled", ctx.Err())
	default:
		return d.CreateNetwork(in)
	}
}

func (d *ManagedBlockchainDouble) CreateNode(i0 *managedblockchain.CreateNodeInput) (r0 *managedblockchain.CreateNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNode", i0)
	r0, _ = returns[0].(*managedblockchain.CreateNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) CreateNodeRequest(i0 *managedblockchain.CreateNodeInput) (r0 *request.Request, r1 *managedblockchain.CreateNodeOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNodeRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.CreateNodeOutput)
	return
}

func (d *ManagedBlockchainDouble) CreateNodeWithContext(i0 context.Context, i1 *managedblockchain.CreateNodeInput, i2 ...request.Option) (r0 *managedblockchain.CreateNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateNodeWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.CreateNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeCreateNodeWithContext(ctx context.Context, in *managedblockchain.CreateNodeInput, _ ...request.Option) (*managedblockchain.CreateNodeOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "CreateNode cancelled", ctx.Err())
	default:
		return d.CreateNode(in)
	}
}

func (d *ManagedBlockchainDouble) CreateProposal(i0 *managedblockchain.CreateProposalInput) (r0 *managedblockchain.CreateProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateProposal", i0)
	r0, _ = returns[0].(*managedblockchain.CreateProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) CreateProposalRequest(i0 *managedblockchain.CreateProposalInput) (r0 *request.Request, r1 *managedblockchain.CreateProposalOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateProposalRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.CreateProposalOutput)
	return
}

func (d *ManagedBlockchainDouble) CreateProposalWithContext(i0 context.Context, i1 *managedblockchain.CreateProposalInput, i2 ...request.Option) (r0 *managedblockchain.CreateProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("CreateProposalWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.CreateProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeCreateProposalWithContext(ctx context.Context, in *managedblockchain.CreateProposalInput, _ ...request.Option) (*managedblockchain.CreateProposalOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "CreateProposal cancelled", ctx.Err())
	default:
		return d.CreateProposal(in)
	}
}

func (d *ManagedBlockchainDouble) DeleteMember(i0 *managedblockchain.DeleteMemberInput) (r0 *managedblockchain.DeleteMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteMember", i0)
	r0, _ = returns[0].(*managedblockchain.DeleteMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) DeleteMemberRequest(i0 *managedblockchain.DeleteMemberInput) (r0 *request.Request, r1 *managedblockchain.DeleteMemberOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteMemberRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.DeleteMemberOutput)
	return
}

func (d *ManagedBlockchainDouble) DeleteMemberWithContext(i0 context.Context, i1 *managedblockchain.DeleteMemberInput, i2 ...request.Option) (r0 *managedblockchain.DeleteMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteMemberWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.DeleteMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeDeleteMemberWithContext(ctx context.Context, in *managedblockchain.DeleteMemberInput, _ ...request.Option) (*managedblockchain.DeleteMemberOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "DeleteMember cancelled", ctx.Err())
	default:
		return d.DeleteMember(in)
	}
}

func (d *ManagedBlockchainDouble) DeleteNode(i0 *managedblockchain.DeleteNodeInput) (r0 *managedblockchain.DeleteNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteNode", i0)
	r0, _ = returns[0].(*managedblockchain.DeleteNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) DeleteNodeRequest(i0 *managedblockchain.DeleteNodeInput) (r0 *request.Request, r1 *managedblockchain.DeleteNodeOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteNodeRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.DeleteNodeOutput)
	return
}

func (d *ManagedBlockchainDouble) DeleteNodeWithContext(i0 context.Context, i1 *managedblockchain.DeleteNodeInput, i2 ...request.Option) (r0 *managedblockchain.DeleteNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("DeleteNodeWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.DeleteNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeDeleteNodeWithContext(ctx context.Context, in *managedblockchain.DeleteNodeInput, _ ...request.Option) (*managedblockchain.DeleteNodeOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "DeleteNode cancelled", ctx.Err())
	default:
		return d.DeleteNode(in)
	}
}

func (d *ManagedBlockchainDouble) GetMember(i0 *managedblockchain.GetMemberInput) (r0 *managedblockchain.GetMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetMember", i0)
	r0, _ = returns[0].(*managedblockchain.GetMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) GetMemberRequest(i0 *managedblockchain.GetMemberInput) (r0 *request.Request, r1 *managedblockchain.GetMemberOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetMemberRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.GetMemberOutput)
	return
}

func (d *ManagedBlockchainDouble) GetMemberWithContext(i0 context.Context, i1 *managedblockchain.GetMemberInput, i2 ...request.Option) (r0 *managedblockchain.GetMemberOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetMemberWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.GetMemberOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeGetMemberWithContext(ctx context.Context, in *managedblockchain.GetMemberInput, _ ...request.Option) (*managedblockchain.GetMemberOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "GetMember cancelled", ctx.Err())
	default:
		return d.GetMember(in)
	}
}

func (d *ManagedBlockchainDouble) GetNetwork(i0 *managedblockchain.GetNetworkInput) (r0 *managedblockchain.GetNetworkOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNetwork", i0)
	r0, _ = returns[0].(*managedblockchain.GetNetworkOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) GetNetworkRequest(i0 *managedblockchain.GetNetworkInput) (r0 *request.Request, r1 *managedblockchain.GetNetworkOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNetworkRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.GetNetworkOutput)
	return
}

func (d *ManagedBlockchainDouble) GetNetworkWithContext(i0 context.Context, i1 *managedblockchain.GetNetworkInput, i2 ...request.Option) (r0 *managedblockchain.GetNetworkOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNetworkWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.GetNetworkOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeGetNetworkWithContext(ctx context.Context, in *managedblockchain.GetNetworkInput, _ ...request.Option) (*managedblockchain.GetNetworkOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "GetNetwork cancelled", ctx.Err())
	default:
		return d.GetNetwork(in)
	}
}

func (d *ManagedBlockchainDouble) GetNode(i0 *managedblockchain.GetNodeInput) (r0 *managedblockchain.GetNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNode", i0)
	r0, _ = returns[0].(*managedblockchain.GetNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) GetNodeRequest(i0 *managedblockchain.GetNodeInput) (r0 *request.Request, r1 *managedblockchain.GetNodeOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNodeRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.GetNodeOutput)
	return
}

func (d *ManagedBlockchainDouble) GetNodeWithContext(i0 context.Context, i1 *managedblockchain.GetNodeInput, i2 ...request.Option) (r0 *managedblockchain.GetNodeOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetNodeWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.GetNodeOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeGetNodeWithContext(ctx context.Context, in *managedblockchain.GetNodeInput, _ ...request.Option) (*managedblockchain.GetNodeOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "GetNode cancelled", ctx.Err())
	default:
		return d.GetNode(in)
	}
}

func (d *ManagedBlockchainDouble) GetProposal(i0 *managedblockchain.GetProposalInput) (r0 *managedblockchain.GetProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetProposal", i0)
	r0, _ = returns[0].(*managedblockchain.GetProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) GetProposalRequest(i0 *managedblockchain.GetProposalInput) (r0 *request.Request, r1 *managedblockchain.GetProposalOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetProposalRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.GetProposalOutput)
	return
}

func (d *ManagedBlockchainDouble) GetProposalWithContext(i0 context.Context, i1 *managedblockchain.GetProposalInput, i2 ...request.Option) (r0 *managedblockchain.GetProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("GetProposalWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.GetProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeGetProposalWithContext(ctx context.Context, in *managedblockchain.GetProposalInput, _ ...request.Option) (*managedblockchain.GetProposalOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "GetProposal cancelled", ctx.Err())
	default:
		return d.GetProposal(in)
	}
}

func (d *ManagedBlockchainDouble) ListInvitations(i0 *managedblockchain.ListInvitationsInput) (r0 *managedblockchain.ListInvitationsOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListInvitations", i0)
	r0, _ = returns[0].(*managedblockchain.ListInvitationsOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListInvitationsPages(i0 *managedblockchain.ListInvitationsInput, i1 func(*managedblockchain.ListInvitationsOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListInvitationsPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListInvitationsPages(in *managedblockchain.ListInvitationsInput, pager func(*managedblockchain.ListInvitationsOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListInvitations", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListInvitationsPagesWithContext(i0 context.Context, i1 *managedblockchain.ListInvitationsInput, i2 func(*managedblockchain.ListInvitationsOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListInvitationsPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListInvitationsPagesWithContext(ctx context.Context, in *managedblockchain.ListInvitationsInput, pager func(*managedblockchain.ListInvitationsOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListInvitations", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListInvitationsRequest(i0 *managedblockchain.ListInvitationsInput) (r0 *request.Request, r1 *managedblockchain.ListInvitationsOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListInvitationsRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListInvitationsOutput)
	return
}

func (d *ManagedBlockchainDouble) ListInvitationsWithContext(i0 context.Context, i1 *managedblockchain.ListInvitationsInput, i2 ...request.Option) (r0 *managedblockchain.ListInvitationsOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListInvitationsWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListInvitationsOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListInvitationsWithContext(ctx context.Context, in *managedblockchain.ListInvitationsInput, _ ...request.Option) (*managedblockchain.ListInvitationsOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListInvitations cancelled", ctx.Err())
	default:
		return d.ListInvitations(in)
	}
}

func (d *ManagedBlockchainDouble) ListMembers(i0 *managedblockchain.ListMembersInput) (r0 *managedblockchain.ListMembersOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListMembers", i0)
	r0, _ = returns[0].(*managedblockchain.ListMembersOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListMembersPages(i0 *managedblockchain.ListMembersInput, i1 func(*managedblockchain.ListMembersOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListMembersPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListMembersPages(in *managedblockchain.ListMembersInput, pager func(*managedblockchain.ListMembersOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListMembers", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListMembersPagesWithContext(i0 context.Context, i1 *managedblockchain.ListMembersInput, i2 func(*managedblockchain.ListMembersOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListMembersPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListMembersPagesWithContext(ctx context.Context, in *managedblockchain.ListMembersInput, pager func(*managedblockchain.ListMembersOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListMembers", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListMembersRequest(i0 *managedblockchain.ListMembersInput) (r0 *request.Request, r1 *managedblockchain.ListMembersOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListMembersRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListMembersOutput)
	return
}

func (d *ManagedBlockchainDouble) ListMembersWithContext(i0 context.Context, i1 *managedblockchain.ListMembersInput, i2 ...request.Option) (r0 *managedblockchain.ListMembersOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListMembersWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListMembersOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListMembersWithContext(ctx context.Context, in *managedblockchain.ListMembersInput, _ ...request.Option) (*managedblockchain.ListMembersOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListMembers cancelled", ctx.Err())
	default:
		return d.ListMembers(in)
	}
}

func (d *ManagedBlockchainDouble) ListNetworks(i0 *managedblockchain.ListNetworksInput) (r0 *managedblockchain.ListNetworksOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNetworks", i0)
	r0, _ = returns[0].(*managedblockchain.ListNetworksOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListNetworksPages(i0 *managedblockchain.ListNetworksInput, i1 func(*managedblockchain.ListNetworksOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNetworksPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNetworksPages(in *managedblockchain.ListNetworksInput, pager func(*managedblockchain.ListNetworksOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListNetworks", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListNetworksPagesWithContext(i0 context.Context, i1 *managedblockchain.ListNetworksInput, i2 func(*managedblockchain.ListNetworksOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNetworksPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNetworksPagesWithContext(ctx context.Context, in *managedblockchain.ListNetworksInput, pager func(*managedblockchain.ListNetworksOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListNetworks", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListNetworksRequest(i0 *managedblockchain.ListNetworksInput) (r0 *request.Request, r1 *managedblockchain.ListNetworksOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNetworksRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListNetworksOutput)
	return
}

func (d *ManagedBlockchainDouble) ListNetworksWithContext(i0 context.Context, i1 *managedblockchain.ListNetworksInput, i2 ...request.Option) (r0 *managedblockchain.ListNetworksOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNetworksWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListNetworksOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNetworksWithContext(ctx context.Context, in *managedblockchain.ListNetworksInput, _ ...request.Option) (*managedblockchain.ListNetworksOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListNetworks cancelled", ctx.Err())
	default:
		return d.ListNetworks(in)
	}
}

func (d *ManagedBlockchainDouble) ListNodes(i0 *managedblockchain.ListNodesInput) (r0 *managedblockchain.ListNodesOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNodes", i0)
	r0, _ = returns[0].(*managedblockchain.ListNodesOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListNodesPages(i0 *managedblockchain.ListNodesInput, i1 func(*managedblockchain.ListNodesOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNodesPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNodesPages(in *managedblockchain.ListNodesInput, pager func(*managedblockchain.ListNodesOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListNodes", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListNodesPagesWithContext(i0 context.Context, i1 *managedblockchain.ListNodesInput, i2 func(*managedblockchain.ListNodesOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNodesPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNodesPagesWithContext(ctx context.Context, in *managedblockchain.ListNodesInput, pager func(*managedblockchain.ListNodesOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListNodes", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListNodesRequest(i0 *managedblockchain.ListNodesInput) (r0 *request.Request, r1 *managedblockchain.ListNodesOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNodesRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListNodesOutput)
	return
}

func (d *ManagedBlockchainDouble) ListNodesWithContext(i0 context.Context, i1 *managedblockchain.ListNodesInput, i2 ...request.Option) (r0 *managedblockchain.ListNodesOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListNodesWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListNodesOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListNodesWithContext(ctx context.Context, in *managedblockchain.ListNodesInput, _ ...request.Option) (*managedblockchain.ListNodesOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListNodes cancelled", ctx.Err())
	default:
		return d.ListNodes(in)
	}
}

func (d *ManagedBlockchainDouble) ListProposalVotes(i0 *managedblockchain.ListProposalVotesInput) (r0 *managedblockchain.ListProposalVotesOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalVotes", i0)
	r0, _ = returns[0].(*managedblockchain.ListProposalVotesOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListProposalVotesPages(i0 *managedblockchain.ListProposalVotesInput, i1 func(*managedblockchain.ListProposalVotesOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalVotesPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalVotesPages(in *managedblockchain.ListProposalVotesInput, pager func(*managedblockchain.ListProposalVotesOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListProposalVotes", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListProposalVotesPagesWithContext(i0 context.Context, i1 *managedblockchain.ListProposalVotesInput, i2 func(*managedblockchain.ListProposalVotesOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalVotesPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalVotesPagesWithContext(ctx context.Context, in *managedblockchain.ListProposalVotesInput, pager func(*managedblockchain.ListProposalVotesOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListProposalVotes", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListProposalVotesRequest(i0 *managedblockchain.ListProposalVotesInput) (r0 *request.Request, r1 *managedblockchain.ListProposalVotesOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalVotesRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListProposalVotesOutput)
	return
}

func (d *ManagedBlockchainDouble) ListProposalVotesWithContext(i0 context.Context, i1 *managedblockchain.ListProposalVotesInput, i2 ...request.Option) (r0 *managedblockchain.ListProposalVotesOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalVotesWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListProposalVotesOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalVotesWithContext(ctx context.Context, in *managedblockchain.ListProposalVotesInput, _ ...request.Option) (*managedblockchain.ListProposalVotesOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListProposalVotes cancelled", ctx.Err())
	default:
		return d.ListProposalVotes(in)
	}
}

func (d *ManagedBlockchainDouble) ListProposals(i0 *managedblockchain.ListProposalsInput) (r0 *managedblockchain.ListProposalsOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposals", i0)
	r0, _ = returns[0].(*managedblockchain.ListProposalsOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) ListProposalsPages(i0 *managedblockchain.ListProposalsInput, i1 func(*managedblockchain.ListProposalsOutput, bool) bool) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalsPages", i0, i1)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalsPages(in *managedblockchain.ListProposalsInput, pager func(*managedblockchain.ListProposalsOutput, bool) (shouldContinue bool)) error {
	return d.Paginate("ListProposals", paginators, in, pager)
}

func (d *ManagedBlockchainDouble) ListProposalsPagesWithContext(i0 context.Context, i1 *managedblockchain.ListProposalsInput, i2 func(*managedblockchain.ListProposalsOutput, bool) bool, i3 ...request.Option) (r0 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalsPagesWithContext", i0, i1, i2, i3)
	r0, _ = returns[0].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalsPagesWithContext(ctx context.Context, in *managedblockchain.ListProposalsInput, pager func(*managedblockchain.ListProposalsOutput, bool) (shouldContinue bool), options ...request.Option) error {
	return d.PaginateWithContext("ListProposals", paginators, ctx, in, pager, options...)
}

func (d *ManagedBlockchainDouble) ListProposalsRequest(i0 *managedblockchain.ListProposalsInput) (r0 *request.Request, r1 *managedblockchain.ListProposalsOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalsRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.ListProposalsOutput)
	return
}

func (d *ManagedBlockchainDouble) ListProposalsWithContext(i0 context.Context, i1 *managedblockchain.ListProposalsInput, i2 ...request.Option) (r0 *managedblockchain.ListProposalsOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("ListProposalsWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.ListProposalsOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeListProposalsWithContext(ctx context.Context, in *managedblockchain.ListProposalsInput, _ ...request.Option) (*managedblockchain.ListProposalsOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "ListProposals cancelled", ctx.Err())
	default:
		return d.ListProposals(in)
	}
}

func (d *ManagedBlockchainDouble) RejectInvitation(i0 *managedblockchain.RejectInvitationInput) (r0 *managedblockchain.RejectInvitationOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("RejectInvitation", i0)
	r0, _ = returns[0].(*managedblockchain.RejectInvitationOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) RejectInvitationRequest(i0 *managedblockchain.RejectInvitationInput) (r0 *request.Request, r1 *managedblockchain.RejectInvitationOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("RejectInvitationRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.RejectInvitationOutput)
	return
}

func (d *ManagedBlockchainDouble) RejectInvitationWithContext(i0 context.Context, i1 *managedblockchain.RejectInvitationInput, i2 ...request.Option) (r0 *managedblockchain.RejectInvitationOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("RejectInvitationWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.RejectInvitationOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeRejectInvitationWithContext(ctx context.Context, in *managedblockchain.RejectInvitationInput, _ ...request.Option) (*managedblockchain.RejectInvitationOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "RejectInvitation cancelled", ctx.Err())
	default:
		return d.RejectInvitation(in)
	}
}

func (d *ManagedBlockchainDouble) VoteOnProposal(i0 *managedblockchain.VoteOnProposalInput) (r0 *managedblockchain.VoteOnProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("VoteOnProposal", i0)
	r0, _ = returns[0].(*managedblockchain.VoteOnProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) VoteOnProposalRequest(i0 *managedblockchain.VoteOnProposalInput) (r0 *request.Request, r1 *managedblockchain.VoteOnProposalOutput) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("VoteOnProposalRequest", i0)
	r0, _ = returns[0].(*request.Request)
	r1, _ = returns[1].(*managedblockchain.VoteOnProposalOutput)
	return
}

func (d *ManagedBlockchainDouble) VoteOnProposalWithContext(i0 context.Context, i1 *managedblockchain.VoteOnProposalInput, i2 ...request.Option) (r0 *managedblockchain.VoteOnProposalOutput, r1 error) {
	d.TestDouble.T().Helper()
	returns := d.TestDouble.Invoke("VoteOnProposalWithContext", i0, i1, i2)
	r0, _ = returns[0].(*managedblockchain.VoteOnProposalOutput)
	r1, _ = returns[1].(error)
	return
}

func (d *ManagedBlockchainDouble) fakeVoteOnProposalWithContext(ctx context.Context, in *managedblockchain.VoteOnProposalInput, _ ...request.Option) (*managedblockchain.VoteOnProposalOutput, error) {

	select {
	case <-ctx.Done():
		return nil, awserr.New(request.CanceledErrorCode, "VoteOnProposal cancelled", ctx.Err())
	default:
		return d.VoteOnProposal(in)
	}
}
